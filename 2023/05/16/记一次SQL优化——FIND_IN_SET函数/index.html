<!DOCTYPE html><html lang=en data-theme=light><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>记一次SQL优化——FIND_IN_SET函数 | 云游憩</title><meta name=author content="Ryu Jung"><meta name=copyright content="Ryu Jung"><meta name=format-detection content="telephone=no"><meta name=theme-color content=#ffffff><meta name=description content=慢SQL优化><meta property=og:type content=article><meta property=og:title content=记一次SQL优化——FIND_IN_SET函数><meta property=og:url content=https://ryujung.github.io/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/index.html><meta property=og:site_name content=云游憩><meta property=og:description content=慢SQL优化><meta property=og:locale content=en_US><meta property=og:image content=https://ryujung.github.io/img/a6fec42e882111ebb6edd017c2d2eca2.jpg><meta property=article:published_time content=2023-05-16T06:52:50.000Z><meta property=article:modified_time content=2023-05-16T07:40:38.050Z><meta property=article:author content="Ryu Jung"><meta name=twitter:card content=summary><meta name=twitter:image content=https://ryujung.github.io/img/a6fec42e882111ebb6edd017c2d2eca2.jpg><link rel="shortcut icon" href=/img/favicon.png><link rel=canonical href=https://ryujung.github.io/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/index.html><link rel=preconnect href=//cdn.jsdelivr.net><link rel=preconnect href=//busuanzi.ibruce.info><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css media=print onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},relativeDate:{homepage:!0,post:!1},runtime:"",dateSuffix:{just:"Just",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:{limitCount:50,languages:{author:"Author: Ryu Jung",link:"Link: ",source:"Source: 云游憩",info:"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0,percent:{toc:!0,rightside:!0}}</script><script id=config-diff>var GLOBAL_CONFIG_SITE={title:"记一次SQL优化——FIND_IN_SET函数",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2023-05-16 15:40:38"}</script><noscript><style type=text/css>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name=generator content="Hexo 6.3.0"></head><body><div id=sidebar><div id=menu-mask></div><div id=sidebar-menus><div class="avatar-img is-center"><img src=/img/v2-86744c307ac17c04e9918711a036840b_1440w.jpg onerror='onerror=null,src="/img/friend_404.gif"' alt=avatar></div><div class="sidebar-site-data site-data is-center"><a href=/archives/ ><div class=headline>Articles</div><div class=length-num>2</div></a><a href=/tags/ ><div class=headline>Tags</div><div class=length-num>0</div></a><a href=/categories/ ><div class=headline>Categories</div><div class=length-num>0</div></a></div><hr></div></div><div class=post id=body-wrap><header class=post-bg id=page-header style=background-image:url(/./img/a6fec42e882111ebb6edd017c2d2eca2.jpg)><nav id=nav><span id=blog-info><a href=/ title=云游憩><span class=site-name>云游憩</span></a></span><div id=menus><div id=toggle-menu><a class=site-page href=javascript:void(0);><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id=post-info><h1 class=post-title>记一次SQL优化——FIND_IN_SET函数</h1><div id=post-meta><div class=meta-firstline><span class=post-meta-date><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class=post-meta-label>Created</span><time class=post-meta-date-created datetime=2023-05-16T06:52:50.000Z title="Created 2023-05-16 14:52:50">2023-05-16</time><span class=post-meta-separator>|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class=post-meta-label>Updated</span><time class=post-meta-date-updated datetime=2023-05-16T07:40:38.050Z title="Updated 2023-05-16 15:40:38">2023-05-16</time></span></div><div class=meta-secondline><span class=post-meta-separator>|</span><span class=post-meta-pv-cv id="" data-flag-title=记一次SQL优化——FIND_IN_SET函数><i class="far fa-eye fa-fw post-meta-icon"></i><span class=post-meta-label>Post View:</span><span id=busuanzi_value_page_pv><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class=layout id=content-inner><div id=post><article class=post-content id=article-container><hr><h3 id=背景><a href=#背景 class=headerlink title=背景></a>背景</h3><p>数据库：MySQL 5.7.20<br>数据库管理工具：DBeaver</p><p>今天在检查数据库慢查询日志时，看到了这么一条统计SQL（数据已做脱敏处理）</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=built_in>count</span>(left_type) # 脱敏处理，不用在意业务逻辑</span><br><span class=line><span class=keyword>FROM</span> temp t </span><br><span class=line><span class=keyword>LEFT</span> <span class=keyword>JOIN</span> company c <span class=keyword>ON</span> t.cid <span class=operator>=</span> c.id</span><br><span class=line><span class=keyword>WHERE</span> FIND_IN_SET(t.kid, <span class=string>&#x27;1001103,1001100,1000071,…中间省略500多字符…,1001074,1001073,1001072&#x27;</span>)</span><br><span class=line><span class=keyword>AND</span> FIND_IN_SET(t.sho_id, <span class=string>&#x27;11183,11474,11336,11034,11189,11260,…中间省略2000多字符…,11410,11370,11108&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_00-38-54.png></p><p>整条SQL执行了377毫秒，不符合执行小于200ms的要求，现在对这条SQL进行优化。</p><h3 id=优化思路><a href=#优化思路 class=headerlink title=优化思路></a>优化思路</h3><p>首先，需要确定，SQL中使用<code>FIND_IN_SET</code>函数对查询列进行操作，应该会导致索引失效。</p><p>为了检查当前SQL是否导致索引失效，使用Explain关键字查看SQL的执行计划，结果如下：</p><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_14-22-49.png></p><p>确实，这里因为使用函数对字段进行运算，导致查询执行了全表扫描。</p><p>值得注意的是，这里的**<code>filtered</code>字段值为100%**，也就是说<br><strong>存储引擎返回的数据在server层过滤后,剩下满足查询条件的比例为100%</strong></p><p>理论上这个值是越大越好的，但是注意，这并<strong>不代表<code>filtered</code>越大，效率越高</strong></p><h3 id=优化步骤><a href=#优化步骤 class=headerlink title=优化步骤></a>优化步骤</h3><p>为了让查询可以正确地走索引，这里把整个查询改为 使用 <code>IN</code> 来过滤字段，如下：</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=built_in>count</span>(left_type)</span><br><span class=line><span class=keyword>FROM</span> temp t </span><br><span class=line><span class=keyword>LEFT</span> <span class=keyword>JOIN</span> company c <span class=keyword>ON</span> t.cid <span class=operator>=</span> c.id</span><br><span class=line><span class=keyword>WHERE</span> t.kid <span class=keyword>IN</span>(<span class=number>1001103</span>,<span class=number>1001100</span>,<span class=number>1000071</span>,…中间省略<span class=number>500</span>多字符…,<span class=number>1001074</span>,<span class=number>1001073</span>,<span class=number>1001072</span>)</span><br><span class=line><span class=keyword>AND</span> t.sho_id <span class=keyword>IN</span>(<span class=number>111183</span>,<span class=number>11474</span>,<span class=number>11336</span>,…中间省略<span class=number>2000</span>多字符…,<span class=number>11410</span>,<span class=number>11370</span>,<span class=number>11108</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意，当前字段和<code>IN</code>括号中的类型是否匹配，如果不匹配，会发生隐式的类型转换，也可能导致索引失效。</p><p>这里确定查询字段都是数字类型，和括号内的类型保持一致，不会发生隐式转换。</p><p>查看当前SQL的执行计划：<br><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_14-22-49.png></p><p>可以看到这里依然没有使用索引，但是再次执行SQL,会发现执行时间由原来的377ms缩短到了42ms !!<br><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_00-37-34.png></p><h3 id=猜测FIND-IN-SET低效原因><a href=#猜测FIND-IN-SET低效原因 class=headerlink title=猜测FIND_IN_SET低效原因></a>猜测<code>FIND_IN_SET</code>低效原因</h3><p>这是<a target=_blank rel=noopener href=https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_find-in-set>官网对<code>FIND_IN_SET</code>的介绍</a>：</p><blockquote><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>FIND_IN_SET(str,strlist)</span><br></pre></td></tr></table></figure><p>Returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings. A string list is a string composed of substrings separated by , characters. If the first argument is a constant string and the second is a column of type SET, the FIND_IN_SET() function is optimized to use bit arithmetic. Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL. This function does not work if the first argument contains a comma (,) character.</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>mysql<span class=operator>&gt;</span> <span class=keyword>SELECT</span> FIND_IN_SET(<span class=string>&#x27;b&#x27;</span>,<span class=string>&#x27;a,b,c,d&#x27;</span>);</span><br><span class=line>        <span class=operator>-</span><span class=operator>&gt;</span> <span class=number>2</span>   # 代表<span class=string>&#x27;a,b,c,d&#x27;</span>这个字符串列表的第 <span class=number>2</span> 个子串由 <span class=string>&#x27;b&#x27;</span> 组成</span><br></pre></td></tr></table></figure><p>翻译:如果字符串str在字符串列表中，则返回1至n范围内的值，表示<strong>子串出现在字符串列表中的位置</strong>。<br>字符串列表是由由字符分开的子字符串组成的字符串。<br>如果第一个参数是常数字符串，而第二个是类型集的列，则优化了Find_in_set（）函数以使用bit算术。<br>如果Str不在Strlist中，或者Strlist是空字符串,则返回0。<br>如果任何一个参数为null，则返回null。<br>如果第一个参数包含逗号（，）字符，则此函数无法正常工作。</p></blockquote><p>可以看到这个方法主要是用于判断字符串中是否包含子串的方法，再反观最初SQL：</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>SELECT</span> <span class=built_in>count</span>(left_type) # 脱敏处理，不用在意业务逻辑</span><br><span class=line><span class=keyword>FROM</span> temp t </span><br><span class=line><span class=keyword>LEFT</span> <span class=keyword>JOIN</span> company c <span class=keyword>ON</span> t.cid <span class=operator>=</span> c.id</span><br><span class=line><span class=keyword>WHERE</span> FIND_IN_SET(t.kid, <span class=string>&#x27;1001103,1001100,1000071,…中间省略500多字符…,1001074,1001073,1001072&#x27;</span>)</span><br><span class=line><span class=keyword>AND</span> FIND_IN_SET(t.sho_id, <span class=string>&#x27;11183,11474,11336,…中间省略2000多字符…,11410,11370,11108&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个最初的SQL中，由于<code>kid</code>和<code>sho_id</code>都是数字类型，而这里使用的<code>FIND_IN_SET</code>函数，导致在全表扫描的同时，还不断对查询的字段进行类型转换，再去和字符串列表的值进行比对，从而导致效率低下。</p><p>虽然整张表只有3.5w行左右的数据，但是当进行全表扫描的时候，<code>FIND_IN_SET</code>造成的效率下降还是非常明显。</p><h3 id=索引是否会提高效率？><a href=#索引是否会提高效率？ class=headerlink title=索引是否会提高效率？></a>索引是否会提高效率？</h3><p>从另外一个角度来说，如果查询的字段存在索引，是否<code>FIND_IN_SET</code>是否可以走索引从而提高效率呢？</p><p>为了验证是否可以走索引，我们在查询条件的两个字段上创建一个联合索引</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>CREATE</span> INDEX idx_kid_sho_id <span class=keyword>ON</span> temp(kid,sho_id);</span><br><span class=line></span><br><span class=line><span class=keyword>SHOW</span> INDEX <span class=keyword>from</span> usertemp;</span><br></pre></td></tr></table></figure><p>此时再查看使用<code>FIND_IN_SET</code> 的SQL执行计划：</p><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_14-22-49.png></p><p>可以看到<code>FIND_IN_SET</code>无法走索引，同样的<code>IN</code>此时也无法走索引</p><h4 id=强制使用索引><a href=#强制使用索引 class=headerlink title=强制使用索引></a>强制使用索引</h4><p>为了测试索引是否可行，下面将尝试强制使用新创建的联合索引</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>explain <span class=keyword>SELECT</span> <span class=built_in>count</span>(left_type) # 脱敏处理，不用在意业务逻辑</span><br><span class=line><span class=keyword>FROM</span> temp t FORCE index(idx_kid_sho_id) # 强制走联合索引</span><br><span class=line><span class=keyword>LEFT</span> <span class=keyword>JOIN</span> company c <span class=keyword>ON</span> t.cid <span class=operator>=</span> c.id</span><br><span class=line><span class=keyword>WHERE</span> FIND_IN_SET(t.kid, <span class=string>&#x27;1001103,1001100,1000071,…中间省略500多字符…,1001074,1001073,1001072&#x27;</span>)</span><br><span class=line><span class=keyword>AND</span> FIND_IN_SET(t.sho_id, <span class=string>&#x27;11183,11474,11336,11034,11189,11260,…中间省略2000多字符…,11410,11370,11108&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_14-22-49.png><br>可以通过执行计划看到，使用<code>FIND_IN_SET</code>尝试强制走索引，然而并不能成功，且执行时间也依然是370ms左右</p><p>接着对使用<code>IN</code>的SQL强制走索引</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>EXPLAIN <span class=keyword>SELECT</span> <span class=built_in>count</span>(left_type)</span><br><span class=line><span class=keyword>FROM</span> temp t FORCE index(idx_kid_sho_id)</span><br><span class=line><span class=keyword>LEFT</span> <span class=keyword>JOIN</span> company c <span class=keyword>ON</span> t.cid <span class=operator>=</span> c.id</span><br><span class=line><span class=keyword>WHERE</span> t.kid <span class=keyword>IN</span>(<span class=number>1001103</span>,<span class=number>1001100</span>,<span class=number>1000071</span>,…中间省略<span class=number>500</span>多字符…,<span class=number>1001074</span>,<span class=number>1001073</span>,<span class=number>1001072</span>)</span><br><span class=line><span class=keyword>AND</span> t.sho_id <span class=keyword>IN</span>(<span class=number>111183</span>,<span class=number>11474</span>,<span class=number>11336</span>,…中间省略<span class=number>2000</span>多字符…,<span class=number>11410</span>,<span class=number>11370</span>,<span class=number>11108</span>);</span><br></pre></td></tr></table></figure><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/Snipaste_2023-05-16_14-25-09.png><br>经过强制走索引后，发现匹配的行数变多了，而且执行时间由原来的40ms上升到了110ms左右！</p><p>可能的原因：索引创建不当，其中的kid和sho_id在查询的temp主表中，具有较强的重复性，强制走复合索引反而增加笛卡尔积，且增大回表查询的消耗（Using index condition），其效率反而不如全表扫描</p><p>对于这种总行数不多（3.5w），或者数据表量在初期阶段较小的场景下，可能会出现使用索引效率低于全表扫描的情况</p><h3 id=拓展：In和Exists应该用哪个><a href=#拓展：In和Exists应该用哪个 class=headerlink title=拓展：In和Exists应该用哪个></a>拓展：<code>In</code>和<code>Exists</code>应该用哪个</h3><p>先说结论：**<code>IN</code>适合于外表大而内表小的情况，而<code>EXISTS</code>适合于外表小而内表大的情况**</p><p>也就是，如果查询的两个表大小相当，那么用IN和Exists差别不大。如果两个表中一个较小，一个是大表，则子查询表大的用Exists，子查询表小的用IN</p><p>举个栗子，对于在某个子查询的结果集中进行筛选，一般有两种写法：</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line># <span class=keyword>Exists</span>方式</span><br><span class=line><span class=keyword>select</span> <span class=built_in>count</span>(<span class=operator>*</span>) <span class=keyword>from</span> temp t</span><br><span class=line><span class=keyword>where</span> <span class=keyword>exists</span>(<span class=keyword>select</span> <span class=number>1</span> <span class=keyword>from</span> company c <span class=keyword>where</span> c.id<span class=operator>=</span>t.cid);</span><br><span class=line></span><br><span class=line># <span class=keyword>In</span>方式</span><br><span class=line><span class=keyword>select</span> <span class=built_in>count</span>(<span class=operator>*</span>) <span class=keyword>from</span> temp</span><br><span class=line><span class=keyword>where</span> cid <span class=keyword>in</span>(<span class=keyword>select</span> id <span class=keyword>from</span> company);</span><br></pre></td></tr></table></figure><p>在这个案例中，</p><ul><li><p>如果外部查询<code>temp</code>表数据量比<code>company</code>（子查询表）大，那么应该使用<code>IN</code></p></li><li><p>如果外部查询<code>temp</code>表数据量比<code>company</code>（子查询表）小，那么应该使用<code>Exists</code></p></li></ul><p>原因：</p><ul><li><p>Exists执行顺序如下： （子查询结果集较大时使用）</p><ol><li><p>首先执行一次外部查询</p></li><li><p>对于外部查询中的每一行分别执行一次子查询，而且每次执行子查询时都会引用外部查询中当前行的值。</p></li><li><p>使用子查询的结果来确定外部查询的结果集。（如果外部查询返回100行，SQL 就将执行101次查询，一次执行外部查询，然后为外部查询返回的每一行执行一次子查询。但实际上，SQL的查询 优化器有可能会找到一种更好的方法来执行相关子查询，而不需要实际执行101次查询。）</p></li></ol></li><li><p>IN的执行过程如下：（子查询结果集较小时使用）</p><ol><li><p>首先运行子查询，获取子结果集</p></li><li><p>主查询再去结果集里去找符合要求的字段列表，.符合要求的输出,反之则不输出</p></li></ol></li></ul><p>MySQL官网有一篇文档，用于<a target=_blank rel=noopener href=https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization-with-exists.html>介绍使用<code>exists</code>优化子查询</a>，大致是讲：</p><p><strong>在某些情况下,使用EXISTS子查询可以比直接使用IN子查询更高效</strong></p><blockquote><p>具体来说,应该在以下情况使用EXISTS子查询:</p><ol><li><p>单表查询中,使用EXISTS替代IN子查询。因为<strong>EXISTS子查询只要找到一条匹配的记录就会立即返回</strong>结果,无需扫描完整个子查询结果集。</p></li><li><p>对于<strong>非常大的子查询结果集,使用EXISTS子查询可以极大提高效率</strong>。因为EXISTS只在找到第一条匹配记录后就停止扫描,而IN子查询需要扫描完整个结果集。</p></li><li><p><strong>EXISTS子查询可以利用索引</strong>更加高效。对子查询中的表添加索引可以大大提高EXISTS子查询的效率。</p></li><li><p>当子查询结果集只返回一列时,使用EXISTS效率更高。因为它只关心存在与否,而不需要返回实际的值。</p></li><li><p>当外面的查询只需要知道子查询是否至少返回一行,而不需要实际的查询结果时,使用EXISTS效率更高。</p></li></ol></blockquote><p>总结下来：<strong>当子查询结果集非常大,并且外查询只关心存在性而不需要实际的结果值时,使用EXISTS子查询可以获得更好的性能优化</strong></p><p>对应当前优化的SQL来说，由于<strong>子查询结果集较小，所以使用IN效率会更高一些</strong></p><h3 id=原因汇总><a href=#原因汇总 class=headerlink title=原因汇总></a>原因汇总</h3><p>使用<code>FIND_IN_SET</code>函数对数字类型进行查询,效率会远低于使用<code>IN</code>子查询的主要原因是:</p><ol><li><code>FIND_IN_SET</code>是字符串操作函数,它接收两个参数,第一个是要查找的字符串,第二个是包含要查找字符串的字符串组。所以使用<code>FIND_IN_SET</code>,MySQL会先将数字转换为字符串,再去字符串组中匹配,这会额外消耗资源。</li><li><code>IN</code>子查询可以利用索引,<code>FIND_IN_SET</code>不能利用索引。<code>IN</code>子查询可以直接使用索引快速判断查询列是否在候选列表中,而<code>FIND_IN_SET</code>每次都需要逐个字符串匹配,无法利用索引。</li><li><code>FIND_IN_SET</code>是逐个字符串匹配,匹配速度较慢。而<code>IN</code>子查询可以将候选列表预处理为Hash表,然后直接Hash查找,速度更快。</li><li><code>FIND_IN_SET</code>需要扫描整个候选列表字符串才能匹配成功或失败,而<code>IN</code>子查询使用索引可以很快判断匹配成功或失败,无需全表扫描。</li></ol><p>所以,总的来说,<code>FIND_IN_SET</code>作为字符串操作函数,无法很好地支持数字类型参数,并且无法利用索引等MySQL的优化功能。相比之下,<code>IN</code>子查询可以充分利用索引和MySQL的查询优化,速度自然远超<code>FIND_IN_SET</code>函数。</p><p>在实际SQL查询中,如果参数类型为数字,我们应该尽量使用IN子查询,而不要使用FIND_IN_SET函数,这可以大大提高查询效率。</p><h3 id=结论><a href=#结论 class=headerlink title=结论></a>结论</h3><p>在使用<code>FIND_IN_SET</code>函数对非字符串进行范围查询时，会导致查询列需要进行<strong>类型的隐式转换</strong>，从而引发查询效率低的问题</p><h3 id=参考><a href=#参考 class=headerlink title=参考></a>参考</h3><p><a target=_blank rel=noopener href=https://www.cnblogs.com/huchong/p/10235260.html>(4) MySQL中EXPLAIN执行计划分析</a><br><a target=_blank rel=noopener href=https://noodb.com/blog/15>MySQL-in和exist的区别</a><br><a target=_blank rel=noopener href=https://www.cnblogs.com/netserver/archive/2008/12/25/1362615.html>SQL中EXISTS的用法</a></p></article><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta>Author: </span><span class=post-copyright-info><a href=https://ryujung.github.io>Ryu Jung</a></span></div><div class=post-copyright__type><span class=post-copyright-meta>Link: </span><span class=post-copyright-info><a href=https://ryujung.github.io/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/ >https://ryujung.github.io/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta>Copyright Notice: </span><span class=post-copyright-info>All articles in this blog are licensed under <a target=_blank rel=noopener href=https://creativecommons.org/licenses/by-nc-sa/4.0/ >CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class=tag_share><div class=post-meta__tag-list></div><div class=post_share><div class=social-share data-image=/./img/a6fec42e882111ebb6edd017c2d2eca2.jpg data-sites=facebook,twitter,wechat,weibo,qq></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js defer=defer></script></div></div><nav class=pagination-post id=pagination><div class="next-post pull-full"><a href=/2023/04/11/%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94Redis%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%AF%A6%E8%A7%A3/ title=强大的缓存数据库——Redis体验与详解><img class=cover src=/img/247402b1880511ebb6edd017c2d2eca2.jpg onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class=pagination-info><div class=label>Next Post</div><div class=next_info>强大的缓存数据库——Redis体验与详解</div></div></a></div></nav></div><div class=aside-content id=aside-content><div class="card-widget card-info"><div class=is-center><div class=avatar-img><img src=/img/v2-86744c307ac17c04e9918711a036840b_1440w.jpg onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt=avatar></div><div class=author-info__name>Ryu Jung</div><div class=author-info__description>畅所欲言的思维天地</div></div><div class="card-info-data site-data is-center"><a href=/archives/ ><div class=headline>Articles</div><div class=length-num>2</div></a><a href=/tags/ ><div class=headline>Tags</div><div class=length-num>0</div></a><a href=/categories/ ><div class=headline>Categories</div><div class=length-num>0</div></a></div><a id=card-info-btn target=_blank rel=noopener href=https://github.com/ryujung><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class=item-headline><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class=announcement_content>This is my Blog</div></div><div class=sticky_layout><div class=card-widget id=card-toc><div class=item-headline><i class="fas fa-stream"></i><span>Catalog</span><span class=toc-percentage></span></div><div class=toc-content><ol class=toc><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%83%8C%E6%99%AF><span class=toc-number>1.</span> <span class=toc-text>背景</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF><span class=toc-number>2.</span> <span class=toc-text>优化思路</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4><span class=toc-number>3.</span> <span class=toc-text>优化步骤</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%8C%9C%E6%B5%8BFIND-IN-SET%E4%BD%8E%E6%95%88%E5%8E%9F%E5%9B%A0><span class=toc-number>4.</span> <span class=toc-text>猜测FIND_IN_SET低效原因</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E4%BC%9A%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F><span class=toc-number>5.</span> <span class=toc-text>索引是否会提高效率？</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95><span class=toc-number>5.1.</span> <span class=toc-text>强制使用索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%8B%93%E5%B1%95%EF%BC%9AIn%E5%92%8CExists%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA><span class=toc-number>6.</span> <span class=toc-text>拓展：In和Exists应该用哪个</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8E%9F%E5%9B%A0%E6%B1%87%E6%80%BB><span class=toc-number>7.</span> <span class=toc-text>原因汇总</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%BB%93%E8%AE%BA><span class=toc-number>8.</span> <span class=toc-text>结论</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%8F%82%E8%80%83><span class=toc-number>9.</span> <span class=toc-text>参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class=item-headline><i class="fas fa-history"></i><span>Recent Post</span></div><div class=aside-list><div class=aside-list-item><a class=thumbnail href=/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/ title=记一次SQL优化——FIND_IN_SET函数><img src=/./img/a6fec42e882111ebb6edd017c2d2eca2.jpg onerror='this.onerror=null,this.src="/img/404.jpg"' alt=记一次SQL优化——FIND_IN_SET函数></a><div class=content><a class=title href=/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/ title=记一次SQL优化——FIND_IN_SET函数>记一次SQL优化——FIND_IN_SET函数</a><time datetime=2023-05-16T06:52:50.000Z title="Created 2023-05-16 14:52:50">2023-05-16</time></div></div><div class=aside-list-item><a class=thumbnail href=/2023/04/11/%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94Redis%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%AF%A6%E8%A7%A3/ title=强大的缓存数据库——Redis体验与详解><img src=/img/247402b1880511ebb6edd017c2d2eca2.jpg onerror='this.onerror=null,this.src="/img/404.jpg"' alt=强大的缓存数据库——Redis体验与详解></a><div class=content><a class=title href=/2023/04/11/%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94Redis%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%AF%A6%E8%A7%A3/ title=强大的缓存数据库——Redis体验与详解>强大的缓存数据库——Redis体验与详解</a><time datetime=2023-04-11T06:52:50.000Z title="Created 2023-04-11 14:52:50">2023-04-11</time></div></div></div></div></div></div></main><footer id=footer><div id=footer-wrap><div class=copyright>&copy;2021 - 2023 By Ryu Jung</div><div class=framework-info><span>Framework </span><a target=_blank rel=noopener href=https://hexo.io>Hexo</a><span class=footer-separator>|</span><span>Theme </span><a target=_blank rel=noopener href=https://github.com/jerryc127/hexo-theme-butterfly>Butterfly</a></div></div></footer></div><div id=rightside><div id=rightside-config-hide><button id=darkmode type=button title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id=hide-aside-btn type=button title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id=rightside-config-show><button id=rightside_config type=button title=Setting><i class="fas fa-cog fa-spin"></i></button><button class=close id=mobile-toc-button type=button title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id=go-up type=button title="Back To Top"><span class=scroll-percent></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src=/js/utils.js></script><script src=/js/main.js></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js></script><div class=js-pjax></div><script async data-pjax src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></body></html>