<!DOCTYPE html><html lang=en data-theme=light><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>RocketMQ事务消息详解 | 云游憩</title><meta name=author content="Ryu Jung"><meta name=copyright content="Ryu Jung"><meta name=format-detection content="telephone=no"><meta name=theme-color content=#ffffff><meta name=description content=RocketMQ事务消息详解><meta property=og:type content=article><meta property=og:title content=RocketMQ事务消息详解><meta property=og:url content=https://ryujung.github.io/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/index.html><meta property=og:site_name content=云游憩><meta property=og:description content=RocketMQ事务消息详解><meta property=og:locale content=en_US><meta property=og:image content=https://ryujung.github.io/img/post/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/apache_rocketmq.png><meta property=article:published_time content=2023-05-18T08:24:59.000Z><meta property=article:modified_time content=2023-05-18T08:33:54.947Z><meta property=article:author content="Ryu Jung"><meta property=article:tag content=RocketMQ><meta name=twitter:card content=summary><meta name=twitter:image content=https://ryujung.github.io/img/post/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/apache_rocketmq.png><link rel="shortcut icon" href=/img/favicon.png><link rel=canonical href=https://ryujung.github.io/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/index.html><link rel=preconnect href=//cdn.jsdelivr.net><link rel=preconnect href=//busuanzi.ibruce.info><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css media=print onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},relativeDate:{homepage:!0,post:!1},runtime:"",dateSuffix:{just:"Just",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:{limitCount:50,languages:{author:"Author: Ryu Jung",link:"Link: ",source:"Source: 云游憩",info:"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0,percent:{toc:!0,rightside:!0}}</script><script id=config-diff>var GLOBAL_CONFIG_SITE={title:"RocketMQ事务消息详解",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2023-05-18 16:33:54"}</script><noscript><style type=text/css>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name=generator content="Hexo 6.3.0"></head><body><div id=sidebar><div id=menu-mask></div><div id=sidebar-menus><div class="avatar-img is-center"><img src=/img/v2-86744c307ac17c04e9918711a036840b_1440w.jpg onerror='onerror=null,src="/img/friend_404.gif"' alt=avatar></div><div class="sidebar-site-data site-data is-center"><a href=/archives/ ><div class=headline>Articles</div><div class=length-num>4</div></a><a href=/tags/ ><div class=headline>Tags</div><div class=length-num>2</div></a><a href=/categories/ ><div class=headline>Categories</div><div class=length-num>0</div></a></div><hr></div></div><div class=post id=body-wrap><header class=post-bg id=page-header style=background-image:url(/img/post/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/apache_rocketmq.png)><nav id=nav><span id=blog-info><a href=/ title=云游憩><span class=site-name>云游憩</span></a></span><div id=menus><div id=toggle-menu><a class=site-page href=javascript:void(0);><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id=post-info><h1 class=post-title>RocketMQ事务消息详解</h1><div id=post-meta><div class=meta-firstline><span class=post-meta-date><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class=post-meta-label>Created</span><time class=post-meta-date-created datetime=2023-05-18T08:24:59.000Z title="Created 2023-05-18 16:24:59">2023-05-18</time><span class=post-meta-separator>|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class=post-meta-label>Updated</span><time class=post-meta-date-updated datetime=2023-05-18T08:33:54.947Z title="Updated 2023-05-18 16:33:54">2023-05-18</time></span></div><div class=meta-secondline><span class=post-meta-separator>|</span><span class=post-meta-pv-cv id="" data-flag-title=RocketMQ事务消息详解><i class="far fa-eye fa-fw post-meta-icon"></i><span class=post-meta-label>Post View:</span><span id=busuanzi_value_page_pv><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class=layout id=content-inner><div id=post><article class=post-content id=article-container><h2 id=开发环境><a href=#开发环境 class=headerlink title=开发环境></a>开发环境</h2><p>在使用RocketMQ消息队列时，尝试使用事务消息，来执行分布式事务，过程中遇到不少麻烦，这里来梳理一下</p><p>使用的RocketMQ版本为：<code>5.1.0</code>，客户端为Java依赖<code>rocketmq-spring-boot-starter</code>，版本：<code>2.2.2</code></p><h2 id=事务消息介绍><a href=#事务消息介绍 class=headerlink title=事务消息介绍></a>事务消息介绍</h2><p>事务消息为 Apache RocketMQ 中的高级特性消息，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。</p><p>通俗地说，就是通过二阶段提交方式，保证<code>本地事务执行</code>和<code>发送消息</code>，这两个操作的一致性（最终一致性）。</p><p>那么RocketMQ事务消息相比而言,解决了哪些特殊问题呢? 主要有以下几点:</p><ol><li><p>消息与本地事务强一致性。普通消息只保证消息发送,但不能保证与本地事务同时成功或同时失败。事务消息通过准备消息-本地事务-提交&#x2F;回滚真实消息的流程,保证了二者的强一致性。</p></li><li><p>自动回滚消息。如果本地事务失败,普通消息无法自动回滚,需要重试或补偿处理。事务消息在本地事务失败时,可以自动回滚消息,简化开发。</p></li><li><p>消息幂等性。同一消息如果重复消费,普通消息会导致业务逻辑再次执行。事务消息通过检查准备消息状态,可以实现幂等消费,避免重复执行业务逻辑。</p></li><li><p>支持消息与远程调用一致。通过RocketMQ事务消息,可以实现消息的发送与远程服务调用在同一个事务内。如果远程调用失败,消息自动回滚。这可以跨进程跨机房保证一致性。</p></li></ol><p>所以,总体来说,RocketMQ事务消息相比直接发送普通消息的优势在于:强一致性保证、自动回滚支持、幂等消费和与远程调用一致这四个方面。这四点可以解决普通消息无法解决的分布式事务问题,比如跨进程跨机房的强一致性要求等。但其实对许多场景来说,普通消息的重试&#x2F;补偿机制也可以满足需要,RocketMQ事务消息的优势并不总是必要的。这还是取决于具体的业务场景和一致性要求。</p><h2 id=踩坑过程><a href=#踩坑过程 class=headerlink title=踩坑过程></a>踩坑过程</h2><p>以下是<code>RocketMQTemplate</code>中有关发送事务消息的源代码：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Send Spring Message in Transaction</span></span><br><span class=line><span class=comment> * ...</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> TransactionSendResult <span class="title function_">sendMessageInTransaction</span><span class=params>(<span class=keyword>final</span> String destination,</span></span><br><span class=line><span class=params>    <span class=keyword>final</span> Message&lt;?&gt; message, <span class=keyword>final</span> Object arg)</span> <span class=keyword>throws</span> MessagingException &#123;</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>        <span class=comment>// 事务监听器的非空判断，为空则抛异常</span></span><br><span class=line>        <span class=keyword>if</span> (((TransactionMQProducer) producer).getTransactionListener() == <span class=literal>null</span>) &#123;</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>&quot;The rocketMQTemplate does not exist TransactionListener&quot;</span>);</span><br><span class=line>        &#125;</span><br><span class=line>        org.apache.rocketmq.common.message.<span class=type>Message</span> <span class=variable>rocketMsg</span> <span class=operator>=</span> <span class=built_in>this</span>.createRocketMqMessage(destination, message);</span><br><span class=line>        <span class=keyword>return</span> producer.sendMessageInTransaction(rocketMsg, arg);</span><br><span class=line>    &#125; <span class=keyword>catch</span> (MQClientException e) &#123;</span><br><span class=line>        <span class=keyword>throw</span> RocketMQUtil.convert(e);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>这段代码中对 <code>getTransactionListener</code>的非空判断，代表如果要发送事务消息，当前<code>TransactionMQProducer</code>上必须绑定事务监听器</p><p>事务监听器将用于 执行本地事务，以及 二次检查本地事务执行结果</p><p>相当于要求<code>发送事务消息</code>和<code>本地事务</code>要在同一个JVM中进行。当然执行的事务和发送消息可以是RPC远程调用方式。但是最理想的应该还是同一个JVM的情况。</p><h2 id=定义事务监听器><a href=#定义事务监听器 class=headerlink title=定义事务监听器></a>定义事务监听器</h2><p>如果要发送事务消息，就需要定义事务消息，用来执行本地事务并向MQ发送执行结果，以此来控制事务消息是否要下发给下游的消费者。</p><p>下面将定义事务监听器来模拟本地事务执行可能遇到的绝大部分情况，以及后续产生的影响，希望能帮助后面学习RocketMQ事务消息的小伙伴理解整个事务流程：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>package</span> com.ryujung.listener;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.alibaba.fastjson.JSON;</span><br><span class=line><span class=keyword>import</span> com.ryujung.model.Order;</span><br><span class=line><span class=keyword>import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=line><span class=keyword>import</span> org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;</span><br><span class=line><span class=keyword>import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionListener;</span><br><span class=line><span class=keyword>import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionState;</span><br><span class=line><span class=keyword>import</span> org.springframework.messaging.Message;</span><br><span class=line><span class=keyword>import</span> java.util.Random;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 生产者将消息发送至Apache RocketMQ服务端。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，</span></span><br><span class=line><span class=comment> * 此时消息被标记为&quot;暂不能投递&quot;，这种状态下的消息即为半事务消息。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 生产者开始执行本地事务逻辑。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=meta>@RocketMQTransactionListener</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TransactionMessageListener</span> <span class=keyword>implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 生产者执行本地事务逻辑。</span></span><br><span class=line><span class=comment>     * 生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：</span></span><br><span class=line><span class=comment>     * 二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</span></span><br><span class=line><span class=comment>     * 二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class=params>(Message msg, Object arg)</span> &#123;</span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            <span class=type>String</span> <span class=variable>payload</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">String</span>((<span class=type>byte</span>[]) msg.getPayload());</span><br><span class=line>            log.info(<span class=string>&quot;处理事务消息：&#123;&#125;，arg：&#123;&#125;，执行本地事务中……&quot;</span>, JSON.parseObject(payload, Order.class), arg);</span><br><span class=line></span><br><span class=line>            <span class=type>Random</span> <span class=variable>random</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>            <span class=keyword>if</span> (random.nextInt(<span class=number>5</span>) &lt; <span class=number>1</span>) &#123;</span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RuntimeException</span>(<span class=string>&quot;本地事务执行发生异常的情况&quot;</span>);</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=type>boolean</span> <span class=variable>finished</span> <span class=operator>=</span> random.nextBoolean();</span><br><span class=line>            <span class=type>boolean</span> <span class=variable>success</span> <span class=operator>=</span> random.nextBoolean();</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (!finished) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;网络中断或抖动等原因导致本地事务尚未完成，成败未知，需要等待MQ后续回查本地事务结果...&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (finished &amp;&amp; success) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;本地事务执行成功，事务消息将重新存储到普通存储系统中，对下游消费者可见，等待被消费者获取并消费&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (finished &amp;&amp; !success) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;本地事务执行失败，本地事务回滚，半事务消息回滚，该事务消息流程终止&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>        &#125; <span class=keyword>catch</span> (Exception e) &#123;</span><br><span class=line>            log.error(<span class=string>&quot;执行本地事务失败，等待重试，半事务消息回滚，该事务消息流程终止，异常信息：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，</span></span><br><span class=line><span class=comment>     * 或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> 回查结果</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class=params>(Message msg)</span> &#123;</span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            <span class=type>String</span> <span class=variable>payload</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">String</span>((<span class=type>byte</span>[]) msg.getPayload());</span><br><span class=line>            log.info(<span class=string>&quot;处理事务消息：&#123;&#125;，确认事务中……&quot;</span>, JSON.parseObject(payload, Order.class));</span><br><span class=line></span><br><span class=line>            <span class=type>Random</span> <span class=variable>random</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>            <span class=keyword>if</span> (random.nextInt(<span class=number>5</span>) &lt; <span class=number>1</span>) &#123;</span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RuntimeException</span>(<span class=string>&quot;随机模拟事务执行发生异常的情况&quot;</span>);</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=type>boolean</span> <span class=variable>finished</span> <span class=operator>=</span> random.nextBoolean();</span><br><span class=line>            <span class=type>boolean</span> <span class=variable>success</span> <span class=operator>=</span> random.nextBoolean();</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (!finished) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;回查结果：本地事务尚未完成，成败未知，需要等待MQ后续再回查本地事务结果...&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (finished &amp;&amp; success) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;回查结果：本地事务执行成功，事务消息将重新存储到普通存储系统中，对下游消费者可见，等待被消费者获取并消费&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>if</span> (finished &amp;&amp; !success) &#123;</span><br><span class=line>                log.info(<span class=string>&quot;回查结果：本地事务执行失败，本地事务回滚，半事务消息回滚，该事务消息流程终止&quot;</span>);</span><br><span class=line>                <span class=keyword>return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class=line>            &#125;</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=line>        &#125; <span class=keyword>catch</span> (Exception e) &#123;</span><br><span class=line>            log.error(<span class=string>&quot;确认本地事务失败，半事务消息回滚，该事务消息流程终止，异常信息：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ官方使用建议：</p><ul><li>避免大量未决事务导致超时</li><li>Apache RocketMQ支持在事务提交阶段异常的情况下发起事务回查，保证事务一致性。</li><li>但生产者应该尽量避免本地事务返回未知结果。大量的事务检查会导致系统性能受损，容易导致事务处理延迟。</li><li>正确处理”进行中”的事务<br>消息回查时，对于正在进行中的事务不要返回Rollback或Commit结果，应继续保持Unknown的状态。<br>一般出现消息回查时事务正在处理的原因为：事务执行较慢，消息回查太快。解决方案如下：<ul><li>将第一次事务回查时间设置较大一些，但可能导致依赖回查的事务提交延迟较大。</li><li>程序能正确识别正在进行中的事务。</li></ul></li></ul><h3 id=事务消息整体流程><a href=#事务消息整体流程 class=headerlink title=事务消息整体流程></a>事务消息整体流程</h3><p>总体来说，事务消息的使用流程是：</p><ol><li>生产者发送事务消息，该操作在MQ中产生半事务消息，暂时对下游消费者不可见</li><li>生产者执行本地事务，并根据执行结果提交&#x2F;回滚消息，即事务监听器的<code>executeLocalTransaction</code>方法被触发</li><li>RocketMQ根据本地事务执行结果对事务消息做不同处理，分为三种执行结果：<ul><li>执行成功（提交）：将半事务消息转换为普通消息，对下游消费者可见，等待消费者消费</li><li>执行失败（回滚）：或者删除半事务消息，并终止本次事务消息</li><li>未知结果（未知或未收到）：MQ在一定时间内未收到结果，将会主动回查生产者事务，从而触发事务监听器的<code>checkLocalTransaction</code>方法，该检查结果分为三种<ul><li>结果成功（提交）或失败（回滚）：同上方的处理方式</li><li>依然未知：MQ在一定回查间隔后，再次执行<code>checkLocalTransaction</code>方法回查事务结果</li><li>达到回查次数上限（默认15次）或者事务消息执行超时：半事务消息将会被强制回滚，事务消息终止</li></ul></li></ul></li><li>消息被消费者消费，消费者不需要关心事务消息的状态</li><li>事务消息的状态完全由生产者控制</li></ol><h3 id=事务相关MQ参数><a href=#事务相关MQ参数 class=headerlink title=事务相关MQ参数></a>事务相关<a target=_blank rel=noopener href=https://rocketmq.apache.org/zh/docs/introduction/03limits/ >MQ参数</a></h3><blockquote><p><strong>事务异常检查间隔</strong><br>默认值：60秒。<br>事务异常检查间隔指的是，半事务消息因系统重启或异常情况导致没有提交，生产者客户端会按照该间隔时间进行事务状态回查。 间隔时长不建议设置过短，否则频繁的回查调用会影响系统性能。</p></blockquote><blockquote><p><strong>半事务消息第一次回查时间</strong><br>默认值：取值等于[事务异常检查间隔] * 最大限制：不超过1小时。</p></blockquote><blockquote><p><strong>半事务消息最大超时时长</strong><br>默认值：4小时。<br>取值范围：不支持自定义修改。<br>半事务消息因系统重启或异常情况导致没有提交，生产者客户端会按照事务异常检查间隔时间进行回查，若超过半事务消息超时时长后没有返回结果，半事务消息将会被强制回滚。 您可以通过监控该指标避免异常事务。</p></blockquote><p><strong>关于回查次数上限（默认15次）</strong></p><p>可以查看<a target=_blank rel=noopener href=https://github.com/apache/rocketmq>RocketMQ项目</a>源码中，有关broker中<a target=_blank rel=noopener href=https://github.com/apache/rocketmq/blob/70480a1fa9aac397fa8c5dbcb352284ad118a891/broker/src/main/java/org/apache/rocketmq/broker/transaction/TransactionalMessageCheckService.java#L25>事务检查的源代码</a>：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>package</span> org.apache.rocketmq.broker.transaction;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.apache.rocketmq.broker.BrokerController;</span><br><span class=line><span class=keyword>import</span> org.apache.rocketmq.common.ServiceThread;</span><br><span class=line><span class=keyword>import</span> ...</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TransactionalMessageCheckService</span> <span class=keyword>extends</span> <span class="title class_">ServiceThread</span> &#123;</span><br><span class=line>    ...</span><br><span class=line>    <span class=keyword>private</span> BrokerController brokerController;</span><br><span class=line>    ...</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">onWaitEnd</span><span class=params>()</span> &#123;</span><br><span class=line>        <span class=type>long</span> <span class=variable>timeout</span> <span class=operator>=</span> brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class=line>        <span class=comment>// 获取broker配置中的最大回查次数配置</span></span><br><span class=line>        <span class=type>int</span> <span class=variable>checkMax</span> <span class=operator>=</span> brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class=line>        <span class=type>long</span> <span class=variable>begin</span> <span class=operator>=</span> System.currentTimeMillis();</span><br><span class=line>        log.info(<span class=string>&quot;Begin to check prepare message, begin time:&#123;&#125;&quot;</span>, begin);</span><br><span class=line>        <span class=comment>// 事务消息服务执行回查操作</span></span><br><span class=line>        <span class=built_in>this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class=built_in>this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class=line>        log.info(<span class=string>&quot;End to check prepare message, consumed time:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，broker在执行事务检查时，会先获取配置中的最大回查次数，然后执行check方法，以下是定义check的接口中的有关描述：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>package</span> org.apache.rocketmq.broker.transaction;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> ...</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">TransactionalMessageService</span> &#123;</span><br><span class=line>    ...</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 翻译：遍历未提交/未回滚的半事务消息，向producer发送check back请求获取事务执行状态。</span></span><br><span class=line><span class=comment>     * Traverse uncommitted/unroll back half message and send check back request to producer to obtain transaction status.</span></span><br><span class=line><span class=comment>     * ...</span></span><br><span class=line><span class=comment>     * 翻译：事务最大检查次数：消息被检查的最大次数，如果超过这个值，消息将被丢弃</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> transactionCheckMax The maximum number of times the message was checked, </span></span><br><span class=line><span class=comment>     * if exceed this value, this message will be discarded.</span></span><br><span class=line><span class=comment>     * ...</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">check</span><span class=params>(<span class=type>long</span> transactionTimeout, <span class=type>int</span> transactionCheckMax, AbstractTransactionalMessageCheckListener listener)</span>;</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，brocker在检查尚未完成的半事务消息时，会查看消息被检查的最大次数，如果超过这个值，事务消息将被丢弃</p><h2 id=RocketTemplate-发送事务消息的时机踩坑><a href=#RocketTemplate-发送事务消息的时机踩坑 class=headerlink title="RocketTemplate 发送事务消息的时机踩坑"></a>RocketTemplate 发送事务消息的时机踩坑</h2><p>另外一个小问题：如果使用<code>spring-boot-starter</code>的<code>RocketMQTemplate</code>操作发送事务消息，请尝试在容器初始化完成之后再进行，不要试图在Bean的初始化阶段操作，会失败</p><h3 id=1-错误演示><a href=#1-错误演示 class=headerlink title="1. 错误演示"></a>1. 错误演示</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre></td><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TransactionMessageService</span> <span class=keyword>implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 试图使用注解方式在初始化阶段进行事务消息的发送</span></span><br><span class=line>    <span class=meta>@PostConstruct</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customInitMethod</span><span class=params>()</span> <span class=keyword>throws</span> Exception &#123;</span><br><span class=line>        ...</span><br><span class=line>        Message&lt;String&gt; message = MessageBuilder.withPayload(payload).build();</span><br><span class=line>        <span class=comment>// 发送事务消息</span></span><br><span class=line>        <span class=type>TransactionSendResult</span> <span class=variable>result</span> <span class=operator>=</span> rocketMQTemplate.sendMessageInTransaction(destination, message, <span class=literal>null</span>);</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>if</span> (result.getLocalTransactionState() == LocalTransactionState.ROLLBACK_MESSAGE) &#123;</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">Exception</span>(<span class=string>&quot;事务消息发送失败，回滚本地事务&quot;</span>);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=meta>@RocketMQTransactionListener</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TransactionMessageListener</span> <span class=keyword>implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class=params>(Message msg, Object arg)</span> &#123;</span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            <span class=type>String</span> <span class=variable>payload</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">String</span>((<span class=type>byte</span>[]) msg.getPayload());</span><br><span class=line>            log.info(<span class=string>&quot;处理事务消息：&#123;&#125;，arg：&#123;&#125;，执行本地事务中……&quot;</span>, JSON.parseObject(payload, Order.class), arg);</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>        &#125; <span class=keyword>catch</span> (Exception e) &#123;</span><br><span class=line>            log.error(<span class=string>&quot;执行本地事务失败，等待重试，异常消息：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class=params>(Message msg)</span> &#123;</span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            <span class=type>String</span> <span class=variable>payload</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">String</span>((<span class=type>byte</span>[]) msg.getPayload());</span><br><span class=line>            log.info(<span class=string>&quot;处理事务消息：&#123;&#125;，确认事务中……&quot;</span>, JSON.parseObject(payload, Order.class));</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class=line>        &#125; <span class=keyword>catch</span> (Exception e) &#123;</span><br><span class=line>            log.error(<span class=string>&quot;确认本地事务失败，异常消息：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>然后启动容器，会报错：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>Caused by: java.lang.IllegalStateException: The rocketMQTemplate does not exist TransactionListener</span><br></pre></td></tr></table></figure><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5_2023-05-18_03-12-15.png></p><p>满脸问号？？？为什么，明明有事务监听器，怎么会提示不存在呢？</p><h3 id=2-问题分析><a href=#2-问题分析 class=headerlink title="2. 问题分析"></a>2. 问题分析</h3><p>如果我们已经明确定义的事务监听器，依然报错提示不存在</p><p>那可能的原因就是：发送事务消息时，事务监听器还没有和<code>rocketMQTemplate</code>完成绑定操作(注册事务监听器)</p><p>那么问题来了：<strong>RocketMQTemplate的事务监听器是在什么时候被注册的？</strong></p><p>先说结论：<strong>是在所有单例Bean初始化之后才被注册的</strong></p><h3 id=3-溯源过程><a href=#3-溯源过程 class=headerlink title="3. 溯源过程"></a>3. 溯源过程</h3><p>在RocketMQ的自动配置类中可以找到问题的端倪，下面是注册事务监听器的配置类源代码：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>package</span> org.apache.rocketmq.spring.autoconfigure;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> ....</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RocketMQTransactionConfiguration</span> <span class=keyword>implements</span> <span class="title class_">ApplicationContextAware</span>, SmartInitializingSingleton &#123;</span><br><span class=line>    ...</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterSingletonsInstantiated</span><span class=params>()</span> &#123;</span><br><span class=line>        Map&lt;String, Object&gt; beans = <span class=built_in>this</span>.applicationContext.getBeansWithAnnotation(RocketMQTransactionListener.class)</span><br><span class=line>            .entrySet().stream().filter(entry -&gt; !ScopedProxyUtils.isScopedTarget(entry.getKey()))</span><br><span class=line>            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class=line></span><br><span class=line>        beans.forEach(<span class=built_in>this</span>::registerTransactionListener);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">registerTransactionListener</span><span class=params>(String beanName, Object bean)</span> &#123;</span><br><span class=line>        Class&lt;?&gt; clazz = AopProxyUtils.ultimateTargetClass(bean);</span><br><span class=line>        ...</span><br><span class=line>        <span class=type>RocketMQTransactionListener</span> <span class=variable>annotation</span> <span class=operator>=</span> clazz.getAnnotation(RocketMQTransactionListener.class);</span><br><span class=line>        <span class=type>RocketMQTemplate</span> <span class=variable>rocketMQTemplate</span> <span class=operator>=</span> (RocketMQTemplate) applicationContext.getBean(annotation.rocketMQTemplateBeanName());</span><br><span class=line>        ...</span><br><span class=line>        <span class=comment>// 在事务监听器注解中使用 rocketMQTemplateBeanName 指定的 rocketMQTemplate</span></span><br><span class=line>        <span class=comment>// 设置的rocketMQTemplate的事务监听器</span></span><br><span class=line>        ((TransactionMQProducer) rocketMQTemplate.getProducer()).setTransactionListener(RocketMQUtil.convert((RocketMQLocalTransactionListener) bean));</span><br><span class=line>        log.debug(<span class=string>&quot;RocketMQLocalTransactionListener &#123;&#125; register to &#123;&#125; success&quot;</span>, clazz.getName(), annotation.rocketMQTemplateBeanName());</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br></pre></td></tr></table></figure><p>可以看到设置监听器的方法调用链是：<br><code>afterSingletonsInstantiated</code> -&gt; <code>registerTransactionListener</code> -&gt; 设置事务监听器</p><p><code>afterSingletonsInstantiated</code>是从哪来的，在什么时候调用呢？</p><p><code>afterSingletonsInstantiated</code>是<code>SmartInitializingSingleton</code>接口的实现方法，该接口方法会在容器中的所有单例bean对象初始化之后进行调用。源代码：</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">SmartInitializingSingleton</span> &#123;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * Invoked right at the end of the singleton pre-instantiation phase,</span></span><br><span class=line><span class=comment>     * with a guarantee that all regular singleton beans have been created already. </span></span><br><span class=line><span class=comment>     * 渣翻：在单例预实例化阶段结束时调用，保证已经创建了所有常规的单例bean。</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">afterSingletonsInstantiated</span><span class=params>()</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>Spring的bean默认都是单例的，所以如果在初始化阶段使用事务消息，会在这段代码前执行，导致以上错误。</p><h2 id=总结><a href=#总结 class=headerlink title=总结></a>总结</h2><ol><li><p>事务消息的发送和事务提交要在同一个JVM中进行，因为是保证本地事务和发送消息的最终一致性，当然执行的事务和发送消息<strong>可以是RPC等方式。但是最理想的应该还是同一个JVM的情况。</strong></p></li><li><p>事务消息的使用对代码入侵严重，为了保证消息不丢失且与事务一致，<strong>需要编写对应的事务监听器方法，分别对二阶段的各种情况进行处理。学习成本高，代码入侵强。</strong></p></li><li><p>在 RocketMQ 中，事务消息的实现方案是先发半消息（半消息对消费者不可见），待半消息发送成功之后，才能执行本地事务，等本地事务执行成功之后，再向 Broker 发送请求将半消息转成正常消息，这样消费者就可以消费此消息。由于本地事务和MQ强绑定，且执行顺序是：<strong>先发MQ，MQ接收后再执行本地事务。</strong>如果MQ出现异常宕机、网络抖动，也会影响到本地事务的执行。</p></li></ol><h2 id=对RocketMQ事务消息的评价><a href=#对RocketMQ事务消息的评价 class=headerlink title=对RocketMQ事务消息的评价></a>对RocketMQ事务消息的评价</h2><p><a target=_blank rel=noopener href=https://zhuanlan.zhihu.com/p/554481474><strong>知乎网友评价</strong></a></p><blockquote><p>MQ的事务消息是解决生产者的单机业务事务与消息发送的一致性。即解决生产者做完核心业务后MQ消息发送不成功，或者MQ消息发送成功后生产者核心业务失败的一致性问题。</p><p>所以RocketMQ从自己的视角搞出来事务消息，让生产者本地事务开启后未提交前成功发送半消息，在通过后续MQ Server的check交互来让生产者根据本地事务成功与否来决定commit or rollback半消息。只能说基于MQ视角是一种解决方案。</p><p>有些开发者更习惯生产者的业务视角，所以直接执行本地事务，完成后发送MQ消息，因为会出现发送MQ消息失败的可能性(可能性比较低)，可以采用定时check补偿发送MQ方案也是可行的。</p><p>无所谓优劣，两种视角下的方案均可。</p></blockquote><p><strong>思否博客评价</strong></p><blockquote><p>RocketMQ的事务消息可以用来解决分布式事务的问题,但并不是一个完整的分布式事务解决方案。<br>它适用于以下场景:</p><ol><li>业务数据和消息数据一致性要求不高的场景。RocketMQ事务消息最大的限制是只支持单Broker消息回查,不支持跨Broker消息回查。这意味着如果消息与业务数据不在同一Broker,事务消息机制无法保证强一致&gt;性。</li><li>本地事务和MQ消息同在一个JVM的场景。RocketMQ事务消息需要应用在消费方法内执行本地事务,并根据事务结果提交或回滚消息。所以最理想的场景是消息消费方和生产方部署在同一JVM,消费方法可以方便执行本地事务。</li><li>可以容忍最终一致性的场景。RocketMQ事务消息机制会导致事务消息在最终提交前有一定的延迟。在某些场景下这种延迟是可以容忍的,就适用于RocketMQ事务消息。</li><li>发消息后需要执行本地事务的场景。RocketMQ事务消息的模式就是:先发送半消息(准备消息),然后执行本地事务,根据事务结果提交或回滚消息。如果业务场景需要这个流程,那么事务消息是一个很好的选择。所以,总体来说,RocketMQ事务消息可以解决一定场景下的分布式事务问题,但由于其本身的限制,不适合需要高度数据一致性和完备XA事务支持的场景。<br>但对于许多业务场景来说,RocketMQ事务消息提供的最终一致性和原子性已经足够,这也是它的优势所在。</li></ol></blockquote><h2 id=扩展：事务消息其他实现方案><a href=#扩展：事务消息其他实现方案 class=headerlink title=扩展：事务消息其他实现方案></a>扩展：事务消息其他实现方案</h2><p>有没有一种办法可以降低代码入侵，降低学习成本，从而实现事务消息呢？有，另一种方案 —— 本地消息表方案。</p><p>下面扩展一下另外一个消息队列及其实现原理 —— QMQ（去哪儿网消息队列）</p><h3 id=QMQ简介><a href=#QMQ简介 class=headerlink title=QMQ简介></a>QMQ简介</h3><blockquote><p>QMQ是去哪儿网内部广泛使用的消息中间件，自2012年诞生以来在去哪儿网所有业务场景中广泛的应用，包括跟交易息息相关的订单场景； 也包括报价搜索等高吞吐量场景。目前在公司内部日常消息qps在60W左右，生产上承载将近4W+消息topic，消息的端到端延迟可以控制在10ms以内。</p></blockquote><p>QMQ使用<code>本地消息表</code>的方式实现分布式事务。详情<a target=_blank rel=noopener href=https://github.com/qunarcorp/qmq/blob/master/docs/cn/transaction.md>查看QMQ官网：事务消息</a></p><p><code>本地消息表</code>就是利用了关系型数据库的事务能力，会在数据库中存放一张本地事务消息表，在进行本地事务操作中加入了本地消息表的插入，即将业务的执行和将消息放入到消息表中的操作放在同一个事务中提交</p><p>这样本地事务执行成功的话，消息肯定也插入成功，然后再调用其他服务，如果其他服务调用成功就修改这条本地消息的状态</p><p>如果失败也不要紧，会有一个后台线程扫描，发现这些状态的消息，会一直调用相应的服务，一般会设置重试的次数，如果一直不行则特殊记录，待人工介入处理</p><p>可以看到，本地事务消息表是一种最大努力通知的思想</p><p>以下是来自QMQ官网中，介绍<a target=_blank rel=noopener href=https://github.com/qunarcorp/qmq/blob/master/docs/cn/transaction.md#qmq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95>事务消息使用方法</a>的相关截图：</p><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/QMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95_2023-05-18_02-21-22.png alt=官网事务消息使用方法截图></p><blockquote><p>在<code>sendMessage</code>执行的时候，消息并没有通过网络发送出去，而仅仅是往业务DB同一个实例上的消息库插入了一条记录，然后注册事务的回调，在这个事务真正提交后消息才从网络发送出去，这个时候如果发送到server成功的话消息会被立即删除掉。而如果消息发送失败则消息就留在消息库里，这个时候我们会有一个补偿任务会将这些消息从消息库里捞出然后重新发送，直到发送成功。</p></blockquote><p>所以发送事务消息整体流程就如下图所示：</p><p><img src=https://www.ryujung.com/wp-content/uploads/2023/05/QMQ%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B.png alt=发送事务消息整体流程></p><h3 id=补偿任务><a href=#补偿任务 class=headerlink title=补偿任务></a>补偿任务</h3><p>在使用事务消息之前需要启动补偿任务服务，使用bin&#x2F;watchdog.sh 来启动补偿任务服务。为了高可用，最好部署多个补偿任务实例，watchdog实现了选举机制，某个时刻只有一个实例在运行，当该实例出现问题时会自动切换到其他实例。</p><h2 id=参考><a href=#参考 class=headerlink title=参考></a>参考</h2><p><a target=_blank rel=noopener href=https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage>RocketMQ官网：事务消息</a><br><a target=_blank rel=noopener href=https://segmentfault.com/a/1190000043760640>思否博客：消息队列中的事务消息</a><br><a target=_blank rel=noopener href="https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;mid=2247491243&amp;idx=1&amp;sn=e064cc4b9e7e0dafcaf5644d7a6ff019&amp;chksm=c16273d2f615fac4b2fa9d9d88dc717ab98e7dddaff3301801dd452e26824b75171454a44cda&amp;scene=21">微信公众号文章：面试官：RocketMQ 分布式事务消息的缺点？</a><br><a target=_blank rel=noopener href=https://www.baiyp.ren/RocketMQ%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.html>www.baiyp.ren博客：RocketMQ消费消息</a></p></article><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta>Author: </span><span class=post-copyright-info><a href=https://ryujung.github.io>Ryu Jung</a></span></div><div class=post-copyright__type><span class=post-copyright-meta>Link: </span><span class=post-copyright-info><a href=https://ryujung.github.io/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/ >https://ryujung.github.io/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta>Copyright Notice: </span><span class=post-copyright-info>All articles in this blog are licensed under <a target=_blank rel=noopener href=https://creativecommons.org/licenses/by-nc-sa/4.0/ >CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class=tag_share><div class=post-meta__tag-list><a class=post-meta__tags href=/tags/RocketMQ/ >RocketMQ</a></div><div class=post_share><div class=social-share data-image=/img/post/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/apache_rocketmq.png data-sites=facebook,twitter,wechat,weibo,qq></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js defer=defer></script></div></div><nav class=pagination-post id=pagination><div class="next-post pull-full"><a href=/2023/05/17/Maven%E7%9A%84Scope%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/ title=Maven的Scope标签详解><img class=cover src=/img/post/Maven%E7%9A%84Scope%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/Apache_Maven_logo.svg_cover.png onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class=pagination-info><div class=label>Next Post</div><div class=next_info>Maven的Scope标签详解</div></div></a></div></nav></div><div class=aside-content id=aside-content><div class="card-widget card-info"><div class=is-center><div class=avatar-img><img src=/img/v2-86744c307ac17c04e9918711a036840b_1440w.jpg onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt=avatar></div><div class=author-info__name>Ryu Jung</div><div class=author-info__description>畅所欲言的思维天地</div></div><div class="card-info-data site-data is-center"><a href=/archives/ ><div class=headline>Articles</div><div class=length-num>4</div></a><a href=/tags/ ><div class=headline>Tags</div><div class=length-num>2</div></a><a href=/categories/ ><div class=headline>Categories</div><div class=length-num>0</div></a></div><a id=card-info-btn target=_blank rel=noopener href=https://github.com/ryujung><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class=item-headline><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class=announcement_content>This is my Blog</div></div><div class=sticky_layout><div class=card-widget id=card-toc><div class=item-headline><i class="fas fa-stream"></i><span>Catalog</span><span class=toc-percentage></span></div><div class=toc-content><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83><span class=toc-number>1.</span> <span class=toc-text>开发环境</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E4%BB%8B%E7%BB%8D><span class=toc-number>2.</span> <span class=toc-text>事务消息介绍</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B><span class=toc-number>3.</span> <span class=toc-text>踩坑过程</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%AE%9A%E4%B9%89%E4%BA%8B%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8><span class=toc-number>4.</span> <span class=toc-text>定义事务监听器</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B><span class=toc-number>4.1.</span> <span class=toc-text>事务消息整体流程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3MQ%E5%8F%82%E6%95%B0><span class=toc-number>4.2.</span> <span class=toc-text>事务相关MQ参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#RocketTemplate-%E5%8F%91%E9%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E6%97%B6%E6%9C%BA%E8%B8%A9%E5%9D%91><span class=toc-number>5.</span> <span class=toc-text>RocketTemplate 发送事务消息的时机踩坑</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#1-%E9%94%99%E8%AF%AF%E6%BC%94%E7%A4%BA><span class=toc-number>5.1.</span> <span class=toc-text>1. 错误演示</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#2-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90><span class=toc-number>5.2.</span> <span class=toc-text>2. 问题分析</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#3-%E6%BA%AF%E6%BA%90%E8%BF%87%E7%A8%8B><span class=toc-number>5.3.</span> <span class=toc-text>3. 溯源过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%80%BB%E7%BB%93><span class=toc-number>6.</span> <span class=toc-text>总结</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%AF%B9RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E8%AF%84%E4%BB%B7><span class=toc-number>7.</span> <span class=toc-text>对RocketMQ事务消息的评价</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88><span class=toc-number>8.</span> <span class=toc-text>扩展：事务消息其他实现方案</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#QMQ%E7%AE%80%E4%BB%8B><span class=toc-number>8.1.</span> <span class=toc-text>QMQ简介</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%A1%A5%E5%81%BF%E4%BB%BB%E5%8A%A1><span class=toc-number>8.2.</span> <span class=toc-text>补偿任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%8F%82%E8%80%83><span class=toc-number>9.</span> <span class=toc-text>参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class=item-headline><i class="fas fa-history"></i><span>Recent Post</span></div><div class=aside-list><div class=aside-list-item><a class=thumbnail href=/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/ title=RocketMQ事务消息详解><img src=/img/post/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/apache_rocketmq.png onerror='this.onerror=null,this.src="/img/404.jpg"' alt=RocketMQ事务消息详解></a><div class=content><a class=title href=/2023/05/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AF%A6%E8%A7%A3/ title=RocketMQ事务消息详解>RocketMQ事务消息详解</a><time datetime=2023-05-18T08:24:59.000Z title="Created 2023-05-18 16:24:59">2023-05-18</time></div></div><div class=aside-list-item><a class=thumbnail href=/2023/05/17/Maven%E7%9A%84Scope%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/ title=Maven的Scope标签详解><img src=/img/post/Maven%E7%9A%84Scope%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/Apache_Maven_logo.svg_cover.png onerror='this.onerror=null,this.src="/img/404.jpg"' alt=Maven的Scope标签详解></a><div class=content><a class=title href=/2023/05/17/Maven%E7%9A%84Scope%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/ title=Maven的Scope标签详解>Maven的Scope标签详解</a><time datetime=2023-05-17T10:00:08.000Z title="Created 2023-05-17 18:00:08">2023-05-17</time></div></div><div class=aside-list-item><a class=thumbnail href=/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/ title=记一次SQL优化——FIND_IN_SET函数><img src=/./img/a6fec42e882111ebb6edd017c2d2eca2.jpg onerror='this.onerror=null,this.src="/img/404.jpg"' alt=记一次SQL优化——FIND_IN_SET函数></a><div class=content><a class=title href=/2023/05/16/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94FIND_IN_SET%E5%87%BD%E6%95%B0/ title=记一次SQL优化——FIND_IN_SET函数>记一次SQL优化——FIND_IN_SET函数</a><time datetime=2023-05-16T06:52:50.000Z title="Created 2023-05-16 14:52:50">2023-05-16</time></div></div><div class=aside-list-item><a class=thumbnail href=/2023/04/11/%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94Redis%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%AF%A6%E8%A7%A3/ title=强大的缓存数据库——Redis体验与详解><img src=/img/247402b1880511ebb6edd017c2d2eca2.jpg onerror='this.onerror=null,this.src="/img/404.jpg"' alt=强大的缓存数据库——Redis体验与详解></a><div class=content><a class=title href=/2023/04/11/%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94Redis%E4%BD%93%E9%AA%8C%E4%B8%8E%E8%AF%A6%E8%A7%A3/ title=强大的缓存数据库——Redis体验与详解>强大的缓存数据库——Redis体验与详解</a><time datetime=2023-04-11T06:52:50.000Z title="Created 2023-04-11 14:52:50">2023-04-11</time></div></div></div></div></div></div></main><footer id=footer><div id=footer-wrap><div class=copyright>&copy;2021 - 2023 By Ryu Jung</div><div class=framework-info><span>Framework </span><a target=_blank rel=noopener href=https://hexo.io>Hexo</a><span class=footer-separator>|</span><span>Theme </span><a target=_blank rel=noopener href=https://github.com/jerryc127/hexo-theme-butterfly>Butterfly</a></div></div></footer></div><div id=rightside><div id=rightside-config-hide><button id=darkmode type=button title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id=hide-aside-btn type=button title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id=rightside-config-show><button id=rightside_config type=button title=Setting><i class="fas fa-cog fa-spin"></i></button><button class=close id=mobile-toc-button type=button title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id=go-up type=button title="Back To Top"><span class=scroll-percent></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src=/js/utils.js></script><script src=/js/main.js></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js></script><div class=js-pjax></div><script async data-pjax src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></body></html>